/**
 * Test utilities for real Airtable API integration tests
 */

import { makeBaseClient, BaseClient } from "../clients/index.ts";
import { type RecordWrite } from "../records/converters.ts";
import type { BaseSchema, TableSchema } from "../types.ts";
// import { linkedItemsSeedData, usersSeedData, getTasksSeedData, getAllTypesSeedData } from "./seed-data.ts";
// @ts-ignore - This file is generated by running 'pnpm run setup-test-base'
import testBaseSchema from "./test-base-schema.generated.ts";
import dotenv from "dotenv";

/**
 * Get configured clients for the test base.
 * Returns table clients for each table and a reset function.
 *
 * @param apiKey - Optional API key (defaults to AIRTABLE_API_KEY env var)
 * @returns Object with table clients and resetBaseData function
 */
export function testBaseClient(apiKey?: string) {
    dotenv.config();
    apiKey = apiKey ?? process.env.AIRTABLE_KIT_TEST_API_KEY;
    const baseClient = makeBaseClient({ baseSchema: testBaseSchema, fetcher: apiKey });
    return {
        baseClient,
        tasksTableClient: baseClient.tables.tasks,
        linkedItemsTableClient: baseClient.tables.linkedItems,
        allTypesTableClient: baseClient.tables.allTypes,
        resetBaseData: () => resetBaseData(baseClient),
    };
}

type RecordWriteFromTableSchema<T extends TableSchema> = RecordWrite<T["fields"][number]>
type RecordWriteFromBase<B extends BaseSchema, N extends B["tables"][number]["name"]> = RecordWriteFromTableSchema<Extract<B["tables"][number], { name: N }>>;

// LinkedItems table - used for testing record links, rollups, and lookups
export const linkedItemsSeedData = [
    { name: "Item A", numberValue: 10, singleLineTextValue: "10" },
    { name: "Item B", numberValue: 20, singleLineTextValue: "20" },
    { name: "Item C", numberValue: 30, singleLineTextValue: "30" },
    { name: "Item D", numberValue: 40, singleLineTextValue: "40" },
    { name: "Item E", numberValue: 50, singleLineTextValue: "50" },
] satisfies RecordWriteFromBase<typeof testBaseSchema, "linkedItems">[];

// Tasks table - will be filled with actual record IDs after users are created
export function getTasksSeedData() {
    return [
        {
            name: "Setup development environment",
            status: "Done",
            priority: 1,
            dueDate: "2025-01-05",
            completed: true,
            notes: "Install all dependencies and configure IDE",
            tags: ["Important"],
        },
        {
            name: "Write project documentation",
            status: "In Progress",
            priority: 2,
            dueDate: "2025-11-10",
            completed: false,
            notes: "Include setup instructions and API reference",
            tags: ["Important"],
        },
        {
            name: "Fix authentication bug",
            status: "Todo",
            priority: 1,
            dueDate: "2025-11-08",
            completed: false,
            notes: "Users unable to login with social accounts",
            tags: ["Urgent", "Important"],
        },
        {
            name: "Review pull requests",
            status: "In Progress",
            priority: 2,
            dueDate: "2025-11-06",
            completed: false,
            notes: "",
            tags: [],
        },
        {
            name: "Update dependencies",
            status: "Todo",
            priority: 3,
            dueDate: "2025-11-15",
            completed: false,
            notes: "Check for security updates",
            tags: [],
        },
        {
            name: "Prepare release notes",
            status: "Todo",
            priority: 2,
            dueDate: "2025-11-12",
            completed: false,
            notes: "Summarize changes for version 1.0",
            tags: ["Important"],
        },
        {
            name: "Migrate to new API",
            status: "Done",
            priority: 1,
            dueDate: "2025-01-02",
            completed: true,
            notes: "Successfully migrated all endpoints",
            tags: [],
        },
        {
            name: "Optimize database queries",
            status: "In Progress",
            priority: 2,
            dueDate: "2025-11-20",
            completed: false,
            notes: "Focus on slow queries in user dashboard",
            tags: ["Important"],
        },
    ] satisfies RecordWriteFromBase<typeof testBaseSchema, "tasks">[];
}

// AllTypes table - comprehensive field type testing
// Uses zip_longest to create records with various field values
// Fields are ordered alphabetically to match fields/index.ts
export function getAllTypesSeedData(linkedItemRecordIds: string[]) {
    // Define arrays of test values for each field type (alphabetically)
    // Note: AutoNumber, Count, CreatedBy, CreatedTime, Formula, LastModifiedBy,
    // LastModifiedTime, Lookup, and Rollup are read-only and computed by Airtable

    const barcodeValues = [
        undefined,
        { text: "123456789", type: "code128" },
        { text: "987654321", type: "code39" },
        { text: "555666777", type: "ean13" },
    ];

    const checkboxValues = [undefined, true, false, true, false];

    const currencyValues = [undefined, 0, 99.99, 1234.56, -50.00];

    const dateValues = [undefined, "2025-01-02", "2025-12-31", "2024-06-15"];

    const dateTimeValues = [undefined, "2025-01-02T10:00:00.000Z", "2025-06-15T14:30:00.000Z", "2024-12-25T00:00:00.000Z"];

    const durationValues = [undefined, 0, 3600, 7200, 1800]; // seconds

    const emailValues = [undefined, "test@example.com", "user@domain.co.uk", "admin@site.org"];

    const multilineTextValues = [undefined, "", "Line 1\nLine 2\nLine 3", "Multi\nline\ntext", "Short"];

    const multipleAttachmentsValues = [
        undefined,
        [],
        [{ url: "https://picsum.photos/200/300" }],
        [
            { url: "https://picsum.photos/400/400" },
            { url: "https://picsum.photos/300/200" }
        ],
    ];

    const multipleCollaboratorsValues = [undefined, [], []];

    const multipleRecordLinksValues = [
        undefined,
        [],
        [linkedItemRecordIds[0]],
        [linkedItemRecordIds[0], linkedItemRecordIds[1]],
        [linkedItemRecordIds[2]],
        [linkedItemRecordIds[1], linkedItemRecordIds[2], linkedItemRecordIds[3]],
    ];

    const multipleSelectsValues = [undefined, [], ["Tag 1"], ["Tag 1", "Tag 2"], ["Tag 2", "Tag 3"]];

    const numberValues = [undefined, 0, 42, -17, 3.14159, 1000000];

    const percentValues = [undefined, 0, 0.5, 1.0, 0.25, 0.75];

    const phoneNumberValues = [undefined, "(555) 111-2222", "+1-555-333-4444", "555.555.5555"];

    const ratingValues = [undefined, 1, 5, 10, 3, 7];

    const richTextValues = [undefined, "", "**Bold** and *italic*", "Rich text content", "Simple"];

    const singleCollaboratorValues = [undefined, undefined, undefined];

    const singleLineTextValues = [undefined, "", "Hello World", "Special !@#$ chars", "Very long text that tests the limits of single line text fields with lots of content"];

    const singleSelectValues = [undefined, "Option A", "Option B", "Option C"];

    const urlValues = [undefined, "https://example.com", "http://test.org/path", "https://domain.com/page?q=1"];

    // Use zip_longest to create records (alphabetically ordered)
    const records = zipLongest(
        barcodeValues,
        checkboxValues,
        currencyValues,
        dateValues,
        dateTimeValues,
        durationValues,
        emailValues,
        multilineTextValues,
        multipleAttachmentsValues,
        multipleCollaboratorsValues,
        multipleRecordLinksValues,
        multipleSelectsValues,
        numberValues,
        percentValues,
        phoneNumberValues,
        ratingValues,
        richTextValues,
        singleCollaboratorValues,
        singleLineTextValues,
        singleSelectValues,
        urlValues
    );

    return records.map((record) => {
        const [
            barcode,
            checkbox,
            currency,
            date,
            dateTime,
            duration,
            email,
            multilineText,
            multipleAttachments,
            multipleCollaborators,
            multipleRecordLinks,
            multipleSelects,
            number,
            percent,
            phoneNumber,
            rating,
            richText,
            singleCollaborator,
            singleLineText,
            singleSelect,
            url,
        ] = record;

        // Build the record object, omitting undefined/null values (alphabetically)
        const result: Record<string, unknown> = {};

        if (barcode !== undefined && barcode !== null) result.barcode = barcode;
        if (checkbox !== undefined && checkbox !== null) result.checkbox = checkbox;
        if (currency !== undefined && currency !== null) result.currency = currency;
        if (date !== undefined && date !== null) result.date = date;
        if (dateTime !== undefined && dateTime !== null) result.dateTime = dateTime;
        if (duration !== undefined && duration !== null) result.duration = duration;
        if (email !== undefined && email !== null) result.email = email;
        if (multilineText !== undefined && multilineText !== null) result.multilineText = multilineText;
        if (multipleAttachments !== undefined && multipleAttachments !== null) result.multipleAttachments = multipleAttachments;
        if (multipleCollaborators !== undefined && multipleCollaborators !== null) result.multipleCollaborators = multipleCollaborators;
        if (multipleRecordLinks !== undefined && multipleRecordLinks !== null) result.multipleRecordLinks = multipleRecordLinks;
        if (multipleSelects !== undefined && multipleSelects !== null) result.multipleSelects = multipleSelects;
        if (number !== undefined && number !== null) result._number = number;
        if (percent !== undefined && percent !== null) result.percent = percent;
        if (phoneNumber !== undefined && phoneNumber !== null) result.phoneNumber = phoneNumber;
        if (rating !== undefined && rating !== null) result.rating = rating;
        if (richText !== undefined && richText !== null) result.richText = richText;
        if (singleCollaborator !== undefined && singleCollaborator !== null) result.singleCollaborator = singleCollaborator;
        if (singleLineText !== undefined && singleLineText !== null) result.singleLineText = singleLineText;
        if (singleSelect !== undefined && singleSelect !== null) result.singleSelect = singleSelect;
        if (url !== undefined && url !== null) result.url = url;

        return result;
    });
}

/**
 * Populate the test base with initial seed data
 */
async function populateSeedData(
    baseClient: BaseClient<typeof testBaseSchema>
): Promise<void> {
    const linkedItemRecords = await baseClient.tables.linkedItems.createRecords(linkedItemsSeedData);
    const linkedItemRecordIds = linkedItemRecords.map((r: any) => r.id);

    const tasksSeedData = getTasksSeedData();
    await baseClient.tables.tasks.createRecords(tasksSeedData);
    const allTypesSeedData = getAllTypesSeedData(linkedItemRecordIds);
    await baseClient.tables.allTypes.createRecords(allTypesSeedData);

    console.log("Seed data populated successfully");
}

/**
 * Reset all data in the test base to the initial seed state.
 * This deletes all records from all tables and recreates the seed data.
 */
export async function resetBaseData(baseClient: BaseClient<typeof testBaseSchema>): Promise<void> {
    for (const tableClient of Object.values(baseClient.tables)) {
        const records = await tableClient.listRecords();

        if (records.length > 0) {
            const recordIds = records.map((r: any) => r.id);
            // Delete in batches of 10 (Airtable API limit)
            for (let i = 0; i < recordIds.length; i += 10) {
                const batch = recordIds.slice(i, i + 10);
                await tableClient.deleteRecords(batch);
            }
        }
    }
    await populateSeedData(baseClient);
}

function zipLongest(...arrays: any[][]): (any | undefined)[][] {
    const maxLen = Math.max(...arrays.map(a => a.length));
    return Array.from({ length: maxLen }, (_, i) =>
        arrays.map(a => a[i])
    );
}